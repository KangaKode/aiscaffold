"""
Architecture Enforcement Tests.

Validates dependency directions and structural rules for {{ project_name }}.
Generated by aiscaffold. Customize FORBIDDEN_IMPORTS for your project.

HOW TO FIX A VIOLATION:
  If module_a/foo.py needs something from module_b/bar.py but module_a
  cannot import from module_b:
  1. Extract the shared interface (dataclass, protocol, utility) into a lower layer
  2. Have both modules import from the lower layer
  3. Run: pytest tests/test_architecture.py -v

Reference: docs/ARCHITECTURE.md
"""

import ast
import os

import pytest

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# =============================================================================
# DEPENDENCY RULES
# Layers (bottom-to-top): {{ layers }}
# Each layer can only import from layers BELOW it.
# =============================================================================

{% set layer_list = layers.split(',') | map('trim') | list -%}
FORBIDDEN_IMPORTS = {
{% for layer in layer_list -%}
{% set forbidden_layers = layer_list[loop.index0 + 1:] -%}
{% if forbidden_layers -%}
    "{{ layer }}": [{% for f in forbidden_layers %}"{{ f }}."{% if not loop.last %}, {% endif %}{% endfor %}],
{% endif -%}
{% endfor -%}
}

MAX_FILE_LINES = 500
FILE_SIZE_CHECK_MODULES = [{% for layer in layer_list %}"{{ layer }}"{% if not loop.last %}, {% endif %}{% endfor %}]

ALLOWED_ROOT_FILES = {
    "README.md", "CLAUDE.md", ".cursorrules", ".gitignore",
    ".pre-commit-config.yaml", ".env.example", ".env",
    "pyproject.toml", "requirements.txt", "Makefile",
    ".copier-answers.yml",
{% if project_type == 'web-app' -%}
    "app.py", "nicegui_app.py",
{% elif project_type == 'cli-tool' -%}
    "cli.py", "main.py",
{% elif project_type == 'api-service' -%}
    "app.py", "main.py",
{% elif project_type == 'multi-agent' -%}
    "app.py", "main.py",
{% endif -%}
}

ALLOWED_ROOT_DIRS = {
{% for layer in layer_list -%}
    "{{ layer }}",
{% endfor -%}
    "docs", "tests", "scripts", "evals",
    "venv", ".venv", "__pycache__",
    ".cursor", ".git", ".github", ".ruff_cache",
}


# =============================================================================
# HELPERS
# =============================================================================


def _get_python_files(directory: str) -> list[str]:
    py_files = []
    if not os.path.isdir(directory):
        return py_files
    for root, _dirs, files in os.walk(directory):
        for f in files:
            if f.endswith(".py") and not f.startswith("__"):
                py_files.append(os.path.join(root, f))
    return py_files


def _get_imports(filepath: str) -> list[tuple[str, int]]:
    imports = []
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=filepath)
    except SyntaxError:
        return imports
    for node in tree.body:
        if isinstance(node, ast.Import):
            for alias in node.names:
                imports.append((alias.name, node.lineno))
        elif isinstance(node, ast.ImportFrom) and node.module:
            imports.append((node.module, node.lineno))
    return imports


def _count_lines(filepath: str) -> int:
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            return sum(1 for _ in f)
    except Exception:
        return 0


# =============================================================================
# TESTS
# =============================================================================


class TestDependencyDirections:

    @pytest.mark.p0
    @pytest.mark.parametrize("module_dir,forbidden", list(FORBIDDEN_IMPORTS.items()))
    def test_no_forbidden_imports(self, module_dir: str, forbidden: list[str]):
        """Verify no forbidden cross-layer imports."""
        module_path = os.path.join(PROJECT_ROOT, module_dir)
        violations = []
        for filepath in _get_python_files(module_path):
            rel = os.path.relpath(filepath, PROJECT_ROOT)
            for name, line in _get_imports(filepath):
                for prefix in forbidden:
                    if name.startswith(prefix):
                        violations.append(f"  {rel}:{line} imports '{name}'")
        if violations:
            pytest.fail(
                f"\n{module_dir}/ has {len(violations)} forbidden import(s):\n"
                + "\n".join(violations)
                + "\n\nSee docs/ARCHITECTURE.md for layering rules."
            )


class TestFileSizeLimits:

    @pytest.mark.p1
    def test_file_sizes(self):
        oversized = []
        for mod in FILE_SIZE_CHECK_MODULES:
            for fp in _get_python_files(os.path.join(PROJECT_ROOT, mod)):
                lc = _count_lines(fp)
                if lc > MAX_FILE_LINES:
                    oversized.append(f"  {os.path.relpath(fp, PROJECT_ROOT)}: {lc} lines")
        if oversized:
            import warnings
            warnings.warn(
                f"\n{len(oversized)} file(s) exceed {MAX_FILE_LINES} lines:\n"
                + "\n".join(oversized),
                stacklevel=2,
            )


class TestModuleStructure:

    @pytest.mark.p0
    def test_core_modules_exist(self):
        for mod in FILE_SIZE_CHECK_MODULES:
            assert os.path.isdir(os.path.join(PROJECT_ROOT, mod)), f"Missing: {mod}/"

    @pytest.mark.p0
    def test_architecture_doc_exists(self):
        assert os.path.isfile(os.path.join(PROJECT_ROOT, "docs", "ARCHITECTURE.md"))

    @pytest.mark.p0
    def test_claude_md_exists(self):
        assert os.path.isfile(os.path.join(PROJECT_ROOT, "CLAUDE.md"))


class TestRootCleanliness:

    @pytest.mark.p1
    def test_no_stray_markdown(self):
        stray = [f for f in os.listdir(PROJECT_ROOT) if f.endswith(".md") and f not in ALLOWED_ROOT_FILES]
        if stray:
            pytest.fail(f"Stray markdown in root: {stray}\nFIX: mv {' '.join(stray)} docs/")

    @pytest.mark.p1
    def test_no_stray_scripts(self):
        stray = [f for f in os.listdir(PROJECT_ROOT) if f.endswith((".command", ".sh")) and f not in ALLOWED_ROOT_FILES]
        if stray:
            pytest.fail(f"Stray scripts in root: {stray}\nFIX: mv them to scripts/")
